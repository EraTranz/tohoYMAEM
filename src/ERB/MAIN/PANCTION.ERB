;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;「ぱんくしょん」100518版
;Emuera専用汎用関数ファイル。多少はバリアント間互換あり
;無断再配布ＯＫ、その際改変・追記は元の機能を損なわない範囲でお願いします
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;「基礎関数群」ファイル
;バリアント・テンプレを選ばずに使用できる簡単な関数が入っています。
;一般的な能力・素質名を使用しているバリアントの場合、ほぼ改変なしで使用することができます。
;一般向けのため、口上・パッチ作者様は目を通しておくとちょっと便利です。
;変更などで今まで使えた機能が使えなくなるということはほぼありません。
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠バリアント設定
;	引数：スコープの何番目の数字を使うかの設定
;ぱんくしょんが占有するCFLAGのスコープを設定します。LOCALに指定した番号から100のCFLAGを使用します
;デフォルトではCFLAG:7900から7999を使用
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
@PANCTION_CFLAG(ARG)
#FUNCTION

;デフォルトでは7900～7999。-1を入れると関連機能全無効
LOCAL = 7900

RETURNF LOCAL+ARG


;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠式中関数
;「#FUNCTION」属性をもち、式中で直接使用する関数です
;「IF PENIS(MASTER)」のように条件式、代入式に使用します
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;-------------------------------------------------
;ペニス判定関数@PENIS
;	引数：対象キャラの登録番号
;ペニスがある場合1を返します
;-------------------------------------------------
@PENIS(ARG)
#FUNCTION
SIF ARG < 0
	RETURNF 0
RETURNF TALENTCHECK(ARG, "オトコ") || TALENTCHECK(ARG, "ふたなり")

;-------------------------------------------------
;主人調教判定関数@MASTERONLY
;	引数：判定したい素質名（文字列）
;TARGETが引数の素質を持っていて、かつ調教者が主人であれば1を返します
;恋慕で助手にまでデレる現象を避ける条件式を簡略化するものです
;文字列に誤りがある場合は警告のためエラー落ちします
;-------------------------------------------------
@MASTERONLY(ARGS)
#FUNCTION
RETURNF !ASSIPLAY && TALENT:(ARGS)

;--------------------------------------------------
;乱数判定関数@PERCENT
;	引数：判定する確率（0～100(％)）
;成否判定を行い、RESULTに判定成功=1、失敗=0を返します
;--------------------------------------------------
@PERCENT(ARG)
#FUNCTION
RETURNF ((ARG - RAND:100) > 0)

;-------------------------------------------------
;ベース割合算出関数@BASERATIO
;	引数0：対象キャラの登録番号
;	引数1：ベース番号（BASE:番号）
;	引数2：正の場合、閾値（％）
;ベース値がMAXBASEの何％あるか返します
;引数2を設定した場合はその％以上なら真を返します
;-------------------------------------------------
@BASERATIO(ARG, ARG:1, ARG:2)
#FUNCTION
RETURNF ARG:2 ? (BASE:ARG:(ARG:1)*100)/MAXBASE:(ARG:1) >= ARG:2 # (BASE:ARG:(ARG:1)*100)/MAXBASE:(ARG:1)

;-------------------------------------------------
;助手素質判定関数@ASSITALENT
;	引数：TALENT番号
;助手の存在を確認してから、引数番号のTALENTの数値を返します
;条件式簡略化のため、助手がいない場合も0を返します
;「指定した素質を持つ助手がいるときに真になる」とご理解ください
;-------------------------------------------------
@ASSITALENT(ARG)
#FUNCTION
RETURNF ASSI >= 0 ? TALENT:ASSI:ARG # 0

;-------------------------------------------------
;助手能力判定関数@ASSIABL
;	引数：ABL番号
;助手の存在を確認してから、引数番号のABLの数値を返します
;条件式簡略化のため、助手がいない場合も0を返します
;-------------------------------------------------
@ASSIABL(ARG)
#FUNCTION
RETURNF ASSI >= 0 ? ABL:ASSI:ARG # 0

;-------------------------------------------------
;助手CFLAG判定関数@ASSICFLAG
;	引数：CFLAG番号
;助手の存在を確認してから、引数番号のCFLAGの数値を返します
;条件式簡略化のため、助手がいない場合も0を返します
;-------------------------------------------------
@ASSICFLAG(ARG)
#FUNCTION
RETURNF ASSI >= 0 ? CFLAG:ASSI:ARG # 0

;-------------------------------------------------
;助手番号判定関数@ASSINO
;助手の存在を確認してから、助手のNOを返します
;助手がいない場合は-1を返します
;NO:ASSIとの違いは、助手がいない場合にエラーにならないことです
;-------------------------------------------------
@ASSINO(ARG)
#FUNCTION
RETURNF ASSI >= 0 ? NO:ASSI # -1

;-------------------------------------------------
;等値チェック関数@EQUALCHECK
;	引数0：チェックされる対象
;	引数1～20：チェックに用いられる数値
;式中で使用する関数です。引数0の値が与えられた値のいずれかと等しかった場合1を返します
;引数に0を含ませる場合は、0を最後の引数にしてはいけません
;引数0はチェックする対象、チェックされる数値は引数1～20まで引き受け可能
;-------------------------------------------------
@EQUALCHECK(ARG, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19, ARG:20)
#FUNCTION
IF ARG
	FOR PL_VAR_I:0, 1, 20
		SIF ARG == ARG:(PL_VAR_I:0)
			RETURNF 1
	NEXT
ELSE
	;指定の変数が0の場合のみ別挙動
	LOCAL = 0
	FOR PL_VAR_I:0, 0, 20
		SIF ARG:(20-(PL_VAR_I:0)) && !LOCAL
			LOCAL = (PL_VAR_I:0)
	NEXT
	FOR PL_VAR_I:0, 1, 20-LOCAL
		SIF ARG == ARG:(PL_VAR_I:0)
			RETURNF 1
	NEXT
ENDIF
RETURNF 0

;-------------------------------------------------
;真値集計関数@TRUECHECK
;	引数0～19：集計対象
;引数のうち真になるものがいくつあるかを数えます
;-------------------------------------------------
@TRUECHECK(ARG, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19)
#FUNCTION
LOCAL = 0
FOR PL_VAR_I:0, 0, 20
	SIF ARG:(PL_VAR_I:0) > 0
		LOCAL ++
NEXT
RETURNF LOCAL

;--------------------------------------------------
;おっぱい比較関数@BUSTSIZE
;	引数0：比較対象１の登録番号
;	引数1：比較対象２の登録番号
;引数で渡された２キャラの胸の大きさを素質で比較します
;どちらかがオトコか不在なら0、引数0のキャラが大きいなら1、引数1のキャラが大きいなら2、同じなら3が返ります
;--------------------------------------------------
@BUSTSIZE(ARG, ARG:1)
#FUNCTION
SIF ARG < 0 || ARG:1 < 0
	RETURNF 0
SIF TALENTCHECK(ARG, "オトコ") || TALENTCHECK(ARG:1, "オトコ")
	RETURNF 0
IF TALENTCHECK(ARG, "爆乳")
	SIF TALENTCHECK(ARG:1, "爆乳")
		RETURNF 3
	RETURNF 1
ELSEIF TALENTCHECK(ARG, "巨乳")
	SIF TALENTCHECK(ARG:1, "爆乳")
		RETURNF 2
	SIF TALENTCHECK(ARG:1, "巨乳")
		RETURNF 3
	RETURNF 1
ELSEIF TALENTCHECK(ARG, "絶壁")
	SIF TALENTCHECK(ARG:1, "絶壁")
		RETURNF 3
	RETURNF 2
ELSEIF TALENTCHECK(ARG, "貧乳")
	SIF TALENTCHECK(ARG:1, "絶壁")
		RETURNF 1
	SIF TALENTCHECK(ARG:1, "貧乳")
		RETURNF 3
	RETURNF 2
ELSE
	SIF TALENTCHECK(ARG:1, "絶壁") || TALENTCHECK(ARG:1, "貧乳")
		RETURNF 1
	SIF TALENTCHECK(ARG:1, "爆乳") || TALENTCHECK(ARG:1, "巨乳")
		RETURNF 2
	RETURNF 3
ENDIF

;--------------------------------------------------
;性感帯参照関数@FAV_FEEL
;	引数：対象キャラの登録番号
;対象キャラの好きな性感帯を返します
;性感帯別陥落素質（尻穴狂い等）があると無条件に優先されます
;～敏感、～鈍感はそれぞれ該当感覚Lvを±1.5補正し、ふたなり・オトコはCを+1補正します
;同じ数字の場合、V、C、A、Bの順で優先します
;戻り値0ならどの感覚も2未満、1ならC、2はV、3はA、4はB性感が好きであることを意味します。
;--------------------------------------------------
@FAV_FEEL(ARG)
#FUNCTION
;性感帯別陥落素質を参照する
SIF TALENTCHECK(ARG, "淫壷") && !TALENTCHECK(ARG, "オトコ")
	RETURNF 2
SIF TALENTCHECK(ARG, "淫核／淫茎") || TALENTCHECK(ARG, "淫核") || TALENTCHECK(ARG, "淫茎")
	RETURNF 1
SIF TALENTCHECK(ARG, "淫尻") || TALENTCHECK(ARG, "尻穴狂い")
	RETURNF 3
SIF TALENTCHECK(ARG, "淫乳")
	RETURNF 4

;各感覚をLOCAL0～3にコピーして10倍に
LOCAL = (ABLCHECK(ARG, "Ｃ感覚"))*10
LOCAL:1 = (ABLCHECK(ARG, "Ｖ感覚"))*10
LOCAL:2 = (ABLCHECK(ARG, "Ａ感覚"))*10
LOCAL:3 = (ABLCHECK(ARG, "Ｂ感覚"))*10

;各敏感・鈍感・ふたなり・オトコの処理
IF TALENTCHECK(ARG, "Ｃ鈍感")
	LOCAL -= 15
ELSEIF TALENTCHECK(ARG, "Ｃ敏感")
	LOCAL += 15
ENDIF
SIF PENIS(ARG)
	LOCAL += 10
IF TALENTCHECK(ARG, "Ｖ鈍感")
	LOCAL:1 -= 15
ELSEIF TALENTCHECK(ARG, "Ｖ敏感")
	LOCAL:1 += 15
ENDIF
IF TALENTCHECK(ARG, "Ａ鈍感")
	LOCAL:2 -= 15
ELSEIF TALENTCHECK(ARG, "Ａ敏感")
	LOCAL:2 += 15
ENDIF
IF TALENTCHECK(ARG, "Ｂ鈍感")
	LOCAL:3 -= 15
ELSEIF TALENTCHECK(ARG, "Ｂ敏感")
	LOCAL:3 += 15
ENDIF

;すべて2未満の場合
SIF LOCAL < 20 && LOCAL:1 < 20 && LOCAL:2 < 20 && LOCAL:3 < 20
	RETURNF 0

;比較
IF LOCAL:1 >= LOCAL && LOCAL:1 >= LOCAL:2 && LOCAL:1 >= LOCAL:3 && !TALENTCHECK(ARG, "オトコ")
	RETURNF 2
ELSEIF LOCAL >= LOCAL:2 && LOCAL >= LOCAL:3
	RETURNF 1
ELSEIF LOCAL:2 >= LOCAL:3
	RETURNF 3
ELSE
	RETURNF 4
ENDIF

;-------------------------------------------------
;RGB色指定関数@RGBCOLOR
;	引数0：Ｒ輝度（0～255）
;	引数1：Ｇ輝度（0～255）
;	引数2：Ｂ輝度（0～255）
;式中で使用する関数です。引数0～3でRGBを指定すると、16進（0xRRGGBB）にして返します
;-------------------------------------------------
@RGBCOLOR(ARG, ARG:1, ARG:2)
#FUNCTION
LOCAL = GETCOLOR()
SETCOLOR ARG, ARG:1, ARG:2
LOCAL:1 = GETCOLOR()
SETCOLOR LOCAL
RETURNF LOCAL:1


;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠初回判定系関数
;式中関数の一種で、初めて呼ばれたときだけ真になる、というタイプの関数群
;CFLAGスコープ0～20を使用し、フラグ節約と代入の省略に機能します
;「IF FIRSTTIME(0)」や、「IF FIRSTCOM(SELECTCOM)」のように使用することで分岐が容易になります
;	共通の引数
;	引数0：イベント・コマンド番号
;	引数1：対象キャラの簡易指定（0=TARGET, 1=MASTER, 2=ASSI, 3=引数2で指定したキャラ）
;	引数2：引数1が=3のとき、対象キャラの登録番号
;	引数3以降は内部的に用いるものなので省略すること
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;-------------------------------------------------
;未読判定関数@FIRSTTIME
;CFLAGスコープ0～3を利用し、イベント番号0～251までの任意な初回判定を管理します
;調教前後などの会話イベントの初回判定に使用することを想定しています
;-------------------------------------------------
@FIRSTTIME(ARG, ARG:1, ARG:2, ARG:3)
#FUNCTION
RETURNF FIRSTTIME_PROCESS(PANCTION_CFLAG(0), 4, ARG, ARG:1, ARG:2, ARG:3)

;-------------------------------------------------
;未読参照関数@FIRSTTIMECHECK
;@FIRSTTIMEの初回判定を更新せずに参照だけを行います
;-------------------------------------------------
@FIRSTTIMECHECK(ARG, ARG:1, ARG:2)
#FUNCTION
RETURNF FIRSTTIME(ARG, ARG:1, ARG:2, 1)

;-------------------------------------------------
;コマンド初回判定関数@FIRSTCOM
;CFLAGスコープ4～19を利用し、コマンド番号0～1007までの任意な初回判定を管理します
;調教コマンド（SELECTCOM等）を直接渡し、コマンドの初回判定に使用することを想定しています
;-------------------------------------------------
@FIRSTCOM(ARG, ARG:1, ARG:2, ARG:3)
#FUNCTION
RETURNF FIRSTTIME_PROCESS(PANCTION_CFLAG(4), 16, ARG, ARG:1, ARG:2, ARG:3)

;-------------------------------------------------
;コマンド初回参照関数@FIRSTCOMCHECK
;@FIRSTCOMの初回判定を更新せずに参照だけを行います
;-------------------------------------------------
@FIRSTCOMCHECK(ARG, ARG:1, ARG:2)
#FUNCTION
RETURNF FIRSTCOM(ARG, ARG:1, ARG:2, 1)

;-------------------------------------------------
;調教内初回関数@ONCEPLAY
;CFLAGを用いず、キャラ登録番号0～999ごとにイベント番号0～63までの任意な調教内初回判定を管理します
;デフォルトだと@EVENTTRAINで初回判定をリセットしてすべて未読に戻します（対応できないバリアントもある）
;その日（ターン）で一度目だけ見られる反応などを設定するために使用することを想定しています
;-------------------------------------------------
@ONCEPLAY(ARG, ARG:1, ARG:2, ARG:3, ARG:4)
#FUNCTION
IF !ARG:1
	ARG:2 = TARGET
ELSEIF ARG:1 == 1
	ARG:2 = MASTER
ELSEIF ARG:1 == 2
	ARG:2 = ASSI
ENDIF
;規定の数を超えるか負か対象キャラがいないなら0を返す
SIF ARG >= 64 || ARG < 0 || ARG:2 >= CHARANUM
	RETURNF 0

;引数4が1か2だとフラグリセット処理のみ行う
IF ARG:4 == 2
	FOR ARG:10, 0, 1000
		LOCAL:(ARG:10) = 0
	NEXT
	RETURNF 0
ELSEIF ARG:4 == 1
	LOCAL:(ARG:2) = 0
	RETURNF 0
ENDIF

IF !GETBIT(LOCAL:(ARG:2), ARG)
	SIF !ARG:3
		SETBIT LOCAL:(ARG:2), ARG
	RETURNF 1
ENDIF
RETURNF 0

;-------------------------------------------------
;クリアチェック関数@GLOBALEVENT
;変数GLOBALを利用してクリアチェックを行います。GLOBAL1つにつきイベント番号0～63まで管理可能
;GLOBAL:1000～1999を使用
;通常
;	引数0：キャラ番号
;	引数1：イベント番号
;	引数2：真だとクリアチェックを更新せず参照のみ
;	引数3：真だとGLOBALのセーブロードを飛ばす
;-------------------------------------------------
@GLOBALEVENT(ARG, ARG:1, ARG:2, ARG:3)
#FUNCTION
;規定の数を超えるか負なら0を返す
SIF ARG:1 >= 64 || ARG < 0
	RETURNF 0
LOCAL = 0
ARG += 1000
SIF !ARG:3
	CALLF SINGLELOADG(ARG)
IF !GETBIT(GLOBAL:ARG, ARG:1)
	SIF !ARG:2
		SETBIT GLOBAL:ARG, ARG:1
	LOCAL = 1
ENDIF
SIF !ARG:3
	CALLF SINGLESAVEG(ARG)
RETURNF LOCAL
;-------------------------------------------------
;クリアチェック参照関数@GLOBALREAD
;@GLOBALEVENTの初回判定を更新せずに参照だけを行います
;そのイベントを見ていれば1、未読なら0を返します
;-------------------------------------------------
@GLOBALREAD(ARG, ARG:1)
#FUNCTION
RETURNF !GLOBALEVENT(ARG, ARG:1, 1)

;-------------------------------------------------
;クリアチェックカウント関数@GLOBALEVENTCHECK
;	引数2：引数1からイベントいくつ分か
;@GLOBALEVENTの初回判定を更新せずに参照だけを行います
;引数1から引数2の数分だけの範囲から、既読のイベントの数を返します
;-------------------------------------------------
@GLOBALEVENTCHECK(ARG, ARG:1, ARG:2, ARG:3)
#FUNCTION
VARSET LOCAL, 0
SIF !ARG:3
	CALLF SINGLELOADG(ARG+1000)
FOR LOCAL, ARG:1, ARG:1+ARG:2
	SIF !GLOBALEVENT(ARG, LOCAL, 1, 1)
		LOCAL:1 ++
NEXT

RETURNF LOCAL:1

;-------------------------------------------------
;クリアチェック実行関数@GLOBALWRITE
;@GLOBALEVENTの初回判定の更新を行います。一般関数です
;-------------------------------------------------
@GLOBALWRITE(ARG, ARG:1)
RETURN GLOBALEVENT(ARG, ARG:1)

;--------------------------------------------------
;グローバル書き込み関数@SINGLESAVEG
;	引数0：GLOBALの番号
;	引数1：軽量化オプション（未保存GLOBALを破棄する）
;仕様上、少々動作が重いため軽量化無しでの多用は推奨されません
;軽量化すると思わぬバグの原因となり得るので、濫用は推奨されません。というかSAVEGLOBALすれば済む話だこれ
;指定した番号のGLOBALのみをSAVEし、それ以外は全て元の（未保存状態の）ままにする式中関数です
;保存されているGLOBALと現在のGLOBALが異なっていても、SAVEを壊さずに現在のGLOBALに復元します
;ただし、引数1を真にするとこの配慮を行わず動作軽量化します（保存してあるGLOBALの状態に戻る。通常はこれで十分）
;テンポラリフラグを使用します。戻り値は保存済みのGLOBALと違う値だった（値を更新した）場合1、同じなら0です
;--------------------------------------------------
@SINGLESAVEG(ARG, ARG:1)
#FUNCTION
IF !ARG:1
	;テンポラリ初期化
	CALLF TEMPRESETALL(0)
	;現在のGLOBALをテンポラリへ逃がす
	FOR LOCAL, 0, VARSIZE("GLOBAL")
		SIF GLOBAL:LOCAL
			CALLF TEMPSET(LOCAL, GLOBAL:LOCAL)
	NEXT
ELSE
	CALLF TEMPSET(ARG, GLOBAL:ARG)
ENDIF

;GLOBAL読み込み
LOADGLOBAL
LOCAL:1 = GLOBAL:ARG
;指定した番号のみテンポラリから引いてくる
GLOBAL:ARG = TEMPFLAG(ARG)

;GLOBAL保存
SAVEGLOBAL

IF !ARG:1
	;未保存GLOBALを元に戻す
	FOR LOCAL, 0, VARSIZE("GLOBAL")
		GLOBAL:LOCAL = TEMPFLAG(LOCAL)
	NEXT
ENDIF

RETURNF LOCAL:1 != GLOBAL:ARG

;--------------------------------------------------
;グローバル読み込み関数@SINGLELOADG
;	引数：GLOBALの番号
;仕様上、少々動作が重いため多用は推奨されません
;指定した番号のGLOBALのみをLOADし、それ以外は全て元の（未保存状態の）ままにする式中関数です
;保存されているGLOBALと現在のGLOBALが異なっていても、SAVEを壊さずに現在のGLOBALに復元します
;テンポラリフラグを使用します。戻り値は読み込んだGLOBALの値です
;--------------------------------------------------
@SINGLELOADG(ARG)
#FUNCTION
;テンポラリ初期化
CALLF TEMPRESETALL(0)
;現在のGLOBALをテンポラリへ逃がす
FOR LOCAL, 0, VARSIZE("GLOBAL")
	SIF GLOBAL:LOCAL
		CALLF TEMPSET(LOCAL, GLOBAL:LOCAL)
NEXT

;GLOBAL読み込み
LOADGLOBAL

;指定した番号以外をテンポラリから引いてくる
FOR LOCAL, 0, VARSIZE("GLOBAL")
	SIF LOCAL != ARG
		GLOBAL:LOCAL = TEMPFLAG(LOCAL)
NEXT

RETURNF GLOBAL:ARG

;-------------------------------------------------
;調教内初回参照関数@ONCEPLAYCHECK
;@ONCEPLAYの初回判定を更新せずに参照だけを行います
;-------------------------------------------------
@ONCEPLAYCHECK(ARG, ARG:1, ARG:2)
#FUNCTION
RETURNF ONCEPLAY(ARG, ARG:1, ARG:2, 1)


;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠テンポラリフラグ系関数
;LOCALでは足りない、欲張りな貴方に
;好き勝手な書き換えができる一時フラグ用の関数です、@TEMPFLAG_0～9のLOCAL配列を利用
;もちろん好き勝手な書き換えもされるので制御を他に渡したら保存されていることを期待してはいけない
;一応全て式中関数ですが、TEMPSET等はCALLFと親和性があります
;こんな大掛かりなの用意しても誰も使わないって？　ハハハこやつめ
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;-------------------------------------------------
;テンポラリ関数@TEMPFLAG
;	引数0：フラグ番号
;	引数1：元関数の引数用
;	引数2：派生関数番号（内部処理用）
;テンポラリフラグを参照し、戻り値にします
;配列の数はLOCALの配列数の10倍まで引き受けます。つまりデフォルトで0～9999です
;変数置き場に困ったら、無駄に大量に管理できることを思い出してあげてください
;万一配列外になったら仕方ないので0を参照します
;-------------------------------------------------
@TEMPFLAG(ARG, ARG:1, ARG:2)
#FUNCTION

LOCAL = ARG/VARSIZE("LOCAL")
LOCAL:1 = ARG%VARSIZE("LOCAL")
;0～999（デフォルトの場合）
IF !LOCAL
	RETURNF TEMPFLAG_0(LOCAL:1, ARG:1, ARG:2)
;1000～1999
ELSEIF LOCAL == 1
	RETURNF TEMPFLAG_1(LOCAL:1, ARG:1, ARG:2)
;2000～2999
ELSEIF LOCAL == 2
	RETURNF TEMPFLAG_2(LOCAL:1, ARG:1, ARG:2)
;3000～3999
ELSEIF LOCAL == 3
	RETURNF TEMPFLAG_3(LOCAL:1, ARG:1, ARG:2)
;4000～4999
ELSEIF LOCAL == 4
	RETURNF TEMPFLAG_4(LOCAL:1, ARG:1, ARG:2)
;5000～5999
ELSEIF LOCAL == 5
	RETURNF TEMPFLAG_5(LOCAL:1, ARG:1, ARG:2)
;6000～6999
ELSEIF LOCAL == 6
	RETURNF TEMPFLAG_6(LOCAL:1, ARG:1, ARG:2)
;7000～7999
ELSEIF LOCAL == 7
	RETURNF TEMPFLAG_7(LOCAL:1, ARG:1, ARG:2)
;8000～8999
ELSEIF LOCAL == 8
	RETURNF TEMPFLAG_8(LOCAL:1, ARG:1, ARG:2)
;9000～9999
ELSEIF LOCAL == 9
	RETURNF TEMPFLAG_9(LOCAL:1, ARG:1, ARG:2)
ENDIF
RETURNF TEMPFLAG_0(LOCAL:1, ARG:1, ARG:2)

;-------------------------------------------------
;テンポラリ代入関数@TEMPSET
;	引数0：フラグ番号
;	引数1：セットする数字
;テンポラリフラグに引数1の値を代入します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPSET(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, ARG:1, 1)

;-------------------------------------------------
;テンポラリ初期化関数@TEMPRESET
;	引数0：フラグ番号の千の位
;	引数1：初期化する数字
;テンポラリフラグ配列を引数の数字で初期化します
;ただし1000区切りです。引数0に入れた数字を千の位とします（0なら0～999を初期化、但しLOCALがデフォの場合）
;その結果の数字（つまり引数まま）を返り値としますが、CALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPRESET(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG*1000, 2, ARG:1)

;-------------------------------------------------
;テンポラリ初期化関数@TEMPRESETALL
;	引数：初期化する数字
;テンポラリフラグ配列すべてを引数の数字で初期化します
;その結果の数字（つまり引数まま）を返り値としますが、CALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPRESETALL(ARG)
#FUNCTION
RETURNF (TEMPFLAG(0, 2, ARG) + TEMPFLAG(1000, 2, ARG) + TEMPFLAG(2000, 2, ARG) + TEMPFLAG(3000, 2, ARG) + TEMPFLAG(4000, 2, ARG) + TEMPFLAG(5000, 2, ARG) + TEMPFLAG(6000, 2, ARG) + TEMPFLAG(7000, 2, ARG) + TEMPFLAG(8000, 2, ARG) + TEMPFLAG(9000, 2, ARG))/10

;-------------------------------------------------
;テンポラリ加算関数@TEMPADD
;	引数0：フラグ番号
;	引数1：加算する数字
;テンポラリフラグに引数の値を加算します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPADD(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 3, ARG:1)

;-------------------------------------------------
;テンポラリ乗算関数@TEMPTIMES
;	引数0：フラグ番号
;	引数1：乗算する数字
;テンポラリフラグに引数の値を乗算しますが小数は使えません
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPTIMES(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 4, ARG:1)

;-------------------------------------------------
;テンポラリ除算関数@TEMPDIVISION
;	引数0：フラグ番号
;	引数1：除算する数字
;テンポラリフラグに引数の値を除算します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPDIVISION(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 5, ARG:1)

;-------------------------------------------------
;テンポラリ余り計算関数@TEMPDIVISORS
;	引数0：フラグ番号
;	引数1：除算する数字
;テンポラリフラグに引数の値を除算し、あまりを代入します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPDIVISORS(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 6, ARG:1)

;-------------------------------------------------
;テンポラリ累乗関数@TEMPPOWER
;	引数0：フラグ番号
;	引数1：除算する数字
;テンポラリフラグを引数乗します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPPOWER(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 7, ARG:1)

;-------------------------------------------------
;テンポラリビット取得関数@TEMPGETBIT
;	引数0：フラグ番号
;	引数1：ビット番号
;テンポラリフラグのビットを取得し、返り値とします。フラグを編集はしません
;-------------------------------------------------
@TEMPGETBIT(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 8, ARG:1)

;-------------------------------------------------
;テンポラリビット立て関数@TEMPSETBIT
;	引数0：フラグ番号
;	引数1：ビット番号
;テンポラリフラグの指定ビットを立てます
;その結果の数字（つまり1）を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPSETBIT(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 9, ARG:1)

;-------------------------------------------------
;テンポラリビット下げ関数@TEMPCLEARBIT
;	引数0：フラグ番号
;	引数1：ビット番号
;テンポラリフラグの指定ビットを降ろします
;その結果の数字（つまり0）を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPCLEARBIT(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 10, ARG:1)

;-------------------------------------------------
;テンポラリビット反転関数@TEMPINVERTBIT
;	引数0：フラグ番号
;	引数1：ビット番号
;テンポラリフラグの指定ビットを反転します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPINVERTBIT(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 11, ARG:1)

;-------------------------------------------------
;記入チェック関数@KOJO_WRITE
;	引数0：記入チェック内容
;	引数1：記入チェック番号
;	引数2：参照のみ
;テンポラリフラグの原理を利用して記入チェックを管理します
;CALLFで呼ぶといい感じです。初期化はしません
;-------------------------------------------------
@KOJO_WRITE(ARG, ARG:1, ARG:2)
#FUNCTION
SIF !ARG:2
	LOCAL:(ARG:1) = ARG
RETURNF LOCAL:(ARG:1)

;-------------------------------------------------
;記入チェック参照関数@KOJO_WROTE
;	引数：記入チェック番号
;テンポラリフラグの原理を利用して記入チェックを参照します
;-------------------------------------------------
@KOJO_WROTE(ARG)
#FUNCTION
RETURNF KOJO_WRITE(0, ARG, 1)


;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠通常関数
;eramakerで使われる通常の関数で、CALL系コマンドで呼び出して使用します
;基本的に、RESULT配列の値を書き換えます
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;-------------------------------------------------
;数値型インプット関数@INPUTINT
;　引数0～19：入力可能な数字
;数値の入力待ちをします。引数に含まれない数字を選んだら自動的に入力待ちをし直します
;有効な数字が入力されたらそれをRESULTへ返して戻ります
;選択肢を汎用処理するため、ループの構文を書く必要がなくなります
;-------------------------------------------------
;注意：0を選択肢に含む場合は引数の並びの最後に配置しないこと
;（例：INPUTINT(3, 2, 1, 0)はダメ。INPUTINT(0, 1, 2, 3)はＯＫ）
;-------------------------------------------------
@INPUTINT(ARG:0, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19)
INPUT
SIF EQUALCHECK(RESULT, ARG:0, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19)
	RETURN RESULT
RESTART

@INPUTINT2(ARG:0, ARG:1)
INPUT
SIF RESULT >= ARG:0 && RESULT <= ARG:1
	RETURN RESULT
RESTART

;-------------------------------------------------
;数値型時間制限インプット関数@TINPUTINT
;	引数0：制限時間(ms)
;	引数1：時間切れ時の戻り値
;	引数2：=1だと残り時間を表示
;	引数3～22：入力可能な数字
;引数3以降で与えられた番号を有効な選択肢として数値の入力を受け付けます
;引数に含まれない数字だとやり直し。RESULTに選んだ値を返します
;-------------------------------------------------
@TINPUTINT(ARG:0, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19, ARG:20, ARG:21, ARG:22)
TINPUT ARG, ARG:1, ARG:2
SIF RESULT == ARG:1 || EQUALCHECK(RESULT, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19, ARG:20, ARG:21, ARG:22)
	RETURN RESULT
RESTART

;--------------------------------------------------
;相性検索関数@RELATION_QUERY
;	引数0：対象のキャラ番号（登録番号ではない。手元に存在している必要はない）
;	引数1：検索条件（0=指定しない, 1=手元にいないキャラのみ選ぶ, 2=手元にいるキャラのみ選ぶ）
;対象キャラと全キャラとの相性を検索して、最も相性の良い相手を抽出します
;--------------------------------------------------
;戻り値一覧
;	RESULT：発見されたキャラとの相性（0=発見不可, 1=対象への相性101～199, 2=対象への相性200以上）
;	RESULT:1：発見したキャラのキャラ番号（発見不可の場合=-1）
;	RESULT:2：発見したキャラの登録番号（手元にいない場合=-1）
;	RESULTS：発見したキャラの呼び名
;	RESULTS:1：発見したキャラの名前
;--------------------------------------------------
@RELATION_QUERY(ARG, ARG:1)
;検索対象の登録番号を抽出
LOCAL = GETCHARA(ARG, 1)
LOCAL:6 = 0
IF LOCAL == -1
	ADDCHARA ARG
	LOCAL = CHARANUM - 1
	LOCAL:6 = 1
ENDIF
LOCAL:1 = -1
IF ARG:1 == 2
	;手元から検索
	FOR PL_VAR_I:0, 0, CHARANUM
		LOCAL:2 = LOCAL:1 < 0 ? 100 # RELATION:LOCAL:(LOCAL:1)
		LOCAL:3 = NO:(PL_VAR_I:0) < 0 || NO:(PL_VAR_I:0) >= VARSIZE("RELATION") ? 100 # RELATION:LOCAL:(NO:(PL_VAR_I:0))
		SIF LOCAL:2 == 0
			LOCAL:2 = 100
		SIF LOCAL:3 == 0
			LOCAL:3 = 100
		;同値の場合ランダムで残す
		;後に引いたほうが大きい場合それを保存
		SIF (LOCAL:2 == LOCAL:3 && RAND:2 && LOCAL:1 >= 0) || LOCAL:2 < LOCAL:3
			LOCAL:1 = NO:(PL_VAR_I:0)
	NEXT
ELSE
	;全体から検索
	;相性を総検索しキャラ番号と相性値を抽出
	FOR PL_VAR_I:0, 0, VARSIZE("RELATION")
		;そもそもCSVがないなら見る必要なし
		SIF EXISTCSV(PL_VAR_I:0, 0)  == 0
			CONTINUE
		;キャラがいるか確認して、いるかつ検索条件=1なら次へ飛ぶ
		SIF GETCHARA(PL_VAR_I:0, 1) != -1 && ARG:1 == 1
			CONTINUE
		LOCAL:2 = LOCAL:1 < 0 ? 100 # RELATION:LOCAL:(LOCAL:1)
		LOCAL:3 = RELATION:LOCAL:(PL_VAR_I:0)
		SIF LOCAL:2 == 0
			LOCAL:2 = 100
		SIF LOCAL:3 == 0
			LOCAL:3 = 100
		;同値の場合ランダムで残す
		;後に引いたほうが大きい場合それを保存
		SIF ((LOCAL:2 == LOCAL:3 && RAND:2 && LOCAL:1 >= 0) || LOCAL:2 < LOCAL:3) && PL_VAR_I:0 < 149
			LOCAL:1 = PL_VAR_I:0
	NEXT
ENDIF
SIF LOCAL:6
	DELCHARA CHARANUM - 1

;名前と登録番号を取得
RESULT:1 = LOCAL:1
IF LOCAL:1 >= 0
	RESULT:2 = GETCHARA(LOCAL:1, 1)
	IF RESULT:2 >= 0
		RESULTS = %CALLNAME:(RESULT:2)%
		RESULTS:1 = %NAME:(RESULT:2)%
	ELSE
		RESULTS = %CSVCALLNAME(LOCAL:1, 0)%
		RESULTS:1 = %CSVNAME(LOCAL:1, 0)%
	ENDIF
ENDIF
;数値に応じてRETURN
SIF RELATION:LOCAL:(LOCAL:1) > 199
	RETURN 2
SIF RELATION:LOCAL:(LOCAL:1) > 100
	RETURN 1
RETURN 0

;--------------------------------------------------
;絶頂強度算出関数@ECST_LEVEL
;CVAB各絶頂の強度を返します。それ以外の絶頂には対応しません。
;多重絶頂の倍率が違うバリアントにも対応できません。
;--------------------------------------------------
;戻り値一覧
;	RESULT：何重絶頂か（0～4）
;	RESULT:1：Ｃ絶頂（1=絶頂, 2=強絶頂, 4=超強絶頂, 9=最強絶頂）
;	RESULT:2：Ｖ絶頂（1=絶頂, 2=強絶頂, 4=超強絶頂, 9=最強絶頂）
;	RESULT:3：Ａ絶頂（1=絶頂, 2=強絶頂, 4=超強絶頂, 9=最強絶頂）
;	RESULT:4：Ｂ絶頂（1=絶頂, 2=強絶頂, 4=超強絶頂, 9=最強絶頂）
;	RESULT:5：賢者の血での空絶頂（ビット演算：1=Ｃ, 2=Ｖ, 4=Ａ, 8=Ｂ絶頂キャンセル）
;--------------------------------------------------
@ECST_LEVEL
;何重絶頂か計算する
LOCAL = 0
SIF NOWEXCHECK(TARGET, "Ｃ絶頂")
	LOCAL += 1
SIF NOWEXCHECK(TARGET, "Ｖ絶頂")
	LOCAL += 1
SIF NOWEXCHECK(TARGET, "Ａ絶頂")
	LOCAL += 1
SIF NOWEXCHECK(TARGET, "Ｂ絶頂")
	LOCAL += 1

;イっているなら各絶頂の強度を算出
IF LOCAL
	RESULT:1 = NOWEXCHECK(TARGET, "Ｃ絶頂") / POWER(2, LOCAL-1)
	RESULT:2 = NOWEXCHECK(TARGET, "Ｖ絶頂") / POWER(2, LOCAL-1)
	RESULT:3 = NOWEXCHECK(TARGET, "Ａ絶頂") / POWER(2, LOCAL-1)
	RESULT:4 = NOWEXCHECK(TARGET, "Ｂ絶頂") / POWER(2, LOCAL-1)
ENDIF

;賢者の血判定
IF ITEMCHECK("賢者の血")
	RESULT:5 = 0
	SIF DOWN:COUNT > 0 && NOWEX:COUNT == 0
		SETBIT RESULT:5, COUNT
ENDIF
RETURN LOCAL

;-------------------------------------------------
;ハートマーク関数@HEART
;	引数0：ハートの数（省略すると1つ）
;	引数1：使用するフォント名（省略するとVerdana）
;中抜きのハートマークを表示します
;-------------------------------------------------
@HEART(ARG, ARGS)
LOCAL = RESULT
ARGS = \@ ARGS == "" ? Verdana # %ARGS% \@
LOCALS = %GETFONT()%

SETFONT CHKFONT(ARGS) ? ARGS # LOCALS

CALL SYMBOLPRINT(ARG, UNICODE(0x2661))

SETFONT LOCALS
RETURN LOCAL

;-------------------------------------------------
;入力待ちハートマーク関数@HEARTW
;	引数0：ハートの数（省略すると1つ）
;	引数1：使用するフォント名（省略するとVerdana）
;	引数2：『」』の代わりに表示する文字列
;	引数3：真にすると、『」』を表示しない
;中抜きハートマークを表示してから『」』を表示し、入力待ち・改行をします
;-------------------------------------------------
@HEARTW(ARG, ARGS, ARGS:1, ARG:1)
CALL HEART(ARG, ARGS)
SIF !ARG:1
	ARGS:1 = \@ ARGS:1 == "" ? 」 # %ARGS:1% \@
PRINTSW ARGS:1
RETURN RESULT

;-------------------------------------------------
;黒ハートマーク関数@HEARTB
;	引数0：ハートの数（省略すると1つ）
;	引数1：使用するフォント名（省略するとSymbol）
;塗りつぶしのハートマークを表示します
;-------------------------------------------------
@HEARTB(ARG, ARGS)
LOCAL = RESULT
IF CHKFONT("Symbol")
	ARGS = \@ ARGS == "" ? Symbol # %ARGS% \@
ELSEIF CHKFONT("Verdana")
	ARGS = \@ ARGS == "" ? Verdana # %ARGS% \@
ENDIF
LOCALS = %GETFONT()%

SETFONT CHKFONT(ARGS) ? ARGS # LOCALS

IF GETFONT() == "Symbol"
	CALL SYMBOLPRINT(ARG, UNICODE(0xA9))
ELSE
	CALL SYMBOLPRINT(ARG, UNICODE(0x2665))
ENDIF

SETFONT LOCALS
RETURN LOCAL

;-------------------------------------------------
;入力待ち黒ハートマーク関数@HEARTBW
;	引数0：ハートの数（省略すると1つ）
;	引数1：使用するフォント名（省略するとSymbol）
;	引数2：『」』の代わりに表示する文字列
;	引数3：真にすると、『」』を表示しない
;塗りつぶしハートマークを表示してから『」』を表示し、入力待ち・改行をします
;-------------------------------------------------
@HEARTBW(ARG, ARGS, ARGS:1, ARG:1)
CALL HEARTB(ARG, ARGS)
SIF !ARG:1
	ARGS:1 = \@ ARGS:1 == "" ? 」 # %ARGS:1% \@
PRINTSW ARGS:1
RETURN RESULT

;-------------------------------------------------
;ハートマーク系デフォルトカラー関数@HEARTD～系
;上記と同じバリエーションがありますが、デフォルトの文字色で表示します
;また、こちらで呼ぶと入力待ちハート系の『」』がデフォルトで表示されません。つまり地の分向け
;引数3を真にすれば逆に『」』を表示するようになります
;-------------------------------------------------
@HEARTD(ARG, ARGS)
LOCAL = GETCOLOR()
RESETCOLOR
CALL HEART(ARG, ARGS)
SETCOLOR LOCAL
RETURN RESULT

@HEARTDW(ARG, ARGS, ARGS:1, ARG:1)
LOCAL = GETCOLOR()
RESETCOLOR
CALL HEARTW(ARG, ARGS, ARGS:1, !ARG:1)
SETCOLOR LOCAL
RETURN RESULT

@HEARTDB(ARG, ARGS)
LOCAL = GETCOLOR()
RESETCOLOR
CALL HEARTB(ARG, ARGS)
SETCOLOR LOCAL
RETURN RESULT

@HEARTDBW(ARG, ARGS, ARGS:1, ARG:1)
LOCAL = GETCOLOR()
RESETCOLOR
CALL HEARTBW(ARG, ARGS, ARGS:1, !ARG:1)
SETCOLOR LOCAL
RETURN RESULT

;-------------------------------------------------
;口上色指定文字列表示関数@PRINTCOLOR～系
;	引数0：文字色
;	引数1：文字列
;指定した文字色で文字列を表示します。カラー指定は16進ですが、RGBCOLOR関数を利用することができます
;PRINT命令同様の「PRINTCOLORL」「PRINTCOLORW」もありますが、書式は面倒です
;例えば…
;CALL PRINTCOLORW(RGBCOLOR(255, 0, 0), "この文字列は赤く表示されて改行待ちをします。")
;-------------------------------------------------
@PRINTCOLOR(ARG, ARGS, ARG:1)
LOCAL = GETCOLOR()
SETCOLOR ARG
PRINTFORM %ARGS%
IF ARG:1 == 1
	PRINTL 
ELSEIF ARG:2 == 2
	PRINTW 
ENDIF
SETCOLOR LOCAL
RETURN RESULT

@PRINTCOLORL(ARG, ARGS)
CALL PRINTCOLOR(ARG, ARGS, 1)
RETURN RESULT

@PRINTCOLORW(ARG, ARGS)
CALL PRINTCOLOR(ARG, ARGS, 2)
RETURN RESULT





;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠内部関数
;バリアント互換のためなどでぱんくしょん内部で使用される子関数・孫関数です
;使用することもできますが原則非推奨です
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;--------------------------------------------------
;能力判定関数@ABLCHECK
;引数：対象のキャラ登録番号, 能力名
;全ABLNAMEと照合して数値を返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@ABLCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(ABL, ARGS)
RETURNF LOCAL > 0 ? ABL:ARG:LOCAL # 0

;--------------------------------------------------
;素質判定関数@TALENTCHECK
;引数：対象のキャラ登録番号, 能力名
;全TALENTNAMEと照合して数値を返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@TALENTCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(TALENT, ARGS)
RETURNF LOCAL > 0 ? TALENT:ARG:LOCAL # 0

;--------------------------------------------------
;経験判定関数@EXPCHECK
;引数：対象のキャラ登録番号, 経験名
;全EXPNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@EXPCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(EXP, ARGS)
RETURNF LOCAL > 0 ? EXP:ARG:LOCAL # 0

;--------------------------------------------------
;刻印判定関数@MARKCHECK
;引数：対象のキャラ登録番号, 刻印名
;全MARKNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@MARKCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(MARK, ARGS)
RETURNF LOCAL > 0 ? MARK:ARG:LOCAL # 0

;--------------------------------------------------
;パラメータ判定関数@PALAMCHECK
;引数：対象のキャラ登録番号, パラメータ名
;全PALAMNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@PALAMCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(PALAM, ARGS)
RETURNF LOCAL > 0 ? PALAM:ARG:LOCAL # 0

;--------------------------------------------------
;アイテム判定関数@ITEMCHECK
;引数：アイテム名
;全ITEMNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@ITEMCHECK(ARGS)
#FUNCTION
LOCAL = GETNUM(ITEM, ARGS)
RETURNF LOCAL > 0 ? ITEM:LOCAL # 0

;--------------------------------------------------
;絶頂判定関数@EXCHECK
;引数：対象のキャラ登録番号, 経験名
;全EXNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@EXCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(EX, ARGS)
RETURNF LOCAL > 0 ? EX:ARG:LOCAL # 0

;--------------------------------------------------
;調教内絶頂判定関数@NOWEXCHECK
;引数：対象のキャラ登録番号, 経験名
;全EXNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@NOWEXCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(EX, ARGS)
RETURNF LOCAL > 0 ? NOWEX:ARG:LOCAL # 0

;--------------------------------------------------
;ソース判定関数@SOURCECHECK
;引数：対象のキャラ登録番号, ソース
;全SOURCENAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@SOURCECHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(SOURCE, ARGS)
RETURNF LOCAL > 0 ? SOURCE:ARG:LOCAL # 0

;--------------------------------------------------
;EQUIP判定関数@EQUIPCHECK
;引数：対象のキャラ登録番号, EQUIP
;全EQUIPNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@EQUIPCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(EQUIP, ARGS)
RETURNF LOCAL > 0 ? EQUIP:ARG:LOCAL # 0

;--------------------------------------------------
;TEQUIP判定関数@TEQUIPCHECK
;引数：対象のキャラ登録番号, TEQUIP
;全TEQUIPNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@TEQUIPCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(TEQUIP, ARGS)
RETURNF LOCAL > 0 ? TEQUIP:ARG:LOCAL # 0

;-------------------------------------------------
;記号表示関数@SYMBOLPRINT
;内部的に使う関数です。呼び出さないでください
;-------------------------------------------------
@SYMBOLPRINT(ARG, ARGS)
ARG = !ARG ? 1 # ARG
FOR PL_VAR_I:0, 0, ARG
	PRINTS ARGS
NEXT
RETURN 0

;-------------------------------------------------
;初回判定処理関数@FIRSTTIME_PROCESS
;	引数0：使用するCFLAGスコープの始点
;	引数1：使用するCFLAGの数（引数0が7000、引数1が20なら、7000～7019の20個を消費する）
;	引数2：イベント・コマンド番号
;	引数3：対象キャラの簡易指定（0=TARGET, 1=MASTER, 2=ASSI, 3=引数2で指定したキャラ）
;	引数4：引数3が=3のとき、対象キャラの登録番号
;	引数5：真の場合、初回判定を参照するのみで更新しない
;CFLAGによる初回判定系の関数の処理を一括して行います
;63*フラグ使用数、の初回判定枠がプールされる（フラグを20確保した場合、63*20で0～1259の1260通り使える）
;-------------------------------------------------
@FIRSTTIME_PROCESS(ARG, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5)
#FUNCTION
IF !ARG:3
	ARG:4 = TARGET
ELSEIF ARG:3 == 1
	ARG:4 = MASTER
ELSEIF ARG:3 == 2
	ARG:4 = ASSI
ENDIF
;規定の数を超えるか負か対象キャラがいないかスコープが負なら0を返す
SIF ARG:2 >= ARG:1*63 || ARG:2 < 0 || ARG:4 < 0 || PANCTION_CFLAG(0) < 0
	RETURNF 0

LOCAL = ARG + ARG:2/63
ARG:2 %= 63

IF !GETBIT(CFLAG:(ARG:4):LOCAL, ARG:2)
	SIF !ARG:5
		SETBIT CFLAG:(ARG:4):LOCAL, ARG:2
	RETURNF 1
ENDIF
RETURNF 0

;-------------------------------------------------
;調教内初回判定初期化関数@ONCEPLAYRESET
;	引数0：対象キャラの簡易指定（0=TARGET, 1=MASTER, 2=ASSI, 3=引数2で指定したキャラ, 4=すべてのキャラ）
;	引数1：引数3が=3のとき、対象キャラの登録番号
;@ONCEPLAYの初回判定をリセットします
;-------------------------------------------------
@ONCEPLAYRESET(ARG, ARG:1)
RETURN ONCEPLAY(0, ARG, ARG:1, 0, ARG == 4 ? 2 # 1)

;デフォルトのフラグリセッタ（全キャラ）
@EVENTTRAIN_PANCTION
CALL ONCEPLAYRESET(4)

;-------------------------------------------------
;テンポラリ保存関数@TEMPFLAG_0～9
;	引数0：フラグ番号
;	引数1：元関数の引数用
;	引数2：派生関数番号（内部処理用）
;テンポラリフラグを保存するための関数群です
;-------------------------------------------------
@TEMPFLAG_0(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_1(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_2(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_3(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_4(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_5(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_6(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_7(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_8(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_9(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG
